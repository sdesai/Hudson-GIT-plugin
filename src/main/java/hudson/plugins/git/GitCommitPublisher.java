package hudson.plugins.git;

import hudson.Launcher;
import hudson.FilePath.FileCallable;
import hudson.model.AbstractBuild;
import hudson.model.AbstractProject;
import hudson.model.BuildListener;
import hudson.model.Descriptor;
import hudson.model.Result;
import hudson.plugins.git.util.BuildChooser;
import hudson.plugins.git.util.BuildData;
import hudson.remoting.VirtualChannel;
import hudson.scm.SCM;
import hudson.tasks.BuildStepDescriptor;
import hudson.tasks.Publisher;
import hudson.util.FormFieldValidator;

import java.io.File;
import java.io.IOException;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;

import javax.servlet.ServletException;

import net.sf.json.JSONObject;

import org.kohsuke.stapler.StaplerRequest;
import org.kohsuke.stapler.StaplerResponse;
import org.spearce.jgit.lib.ObjectId;
import org.spearce.jgit.transport.RemoteConfig;

public class GitCommitPublisher extends Publisher implements Serializable {

	public Descriptor<Publisher> getDescriptor() {
		return DESCRIPTOR;
	}

	public boolean needsToRunAfterFinalized() {
		return true;
	}

	public boolean perform(final AbstractBuild<?, ?> build,
			Launcher launcher, final BuildListener listener)
			throws InterruptedException {

		final SCM scm = build.getProject().getScm();

		if (!(scm instanceof GitSCM)) {
			return false;
		}

		final String projectName = build.getProject().getName();
		final int buildNumber = build.getNumber();
		final Result buildResult = build.getResult();
		
		boolean canPerform;
		try {
			canPerform = build.getProject().getWorkspace().act(
					new FileCallable<Boolean>() {

						public Boolean invoke(File workspace, VirtualChannel channel) throws IOException {

							if (buildResult.isBetterOrEqualTo(Result.SUCCESS)) {
	
								GitSCM gitSCM = (GitSCM) scm;
	
								IGitAPI git = new GitAPI(GitSCM.DescriptorImpl.DESCRIPTOR.getGitExe(), build.getProject().getWorkspace(), listener);
	
								// We delete the old tag generated by the SCM plugin
								String badTag = "hudson-" + projectName  + "-" + buildNumber;
								git.deleteTag(badTag);

								String tag = projectName + "-" + buildNumber; 

								git.commitAll("Committing Build Tag: " + tag);
								git.tag(tag, "Integration Build Tag: " + tag);

								RemoteConfig remote = gitSCM.getRepositories().get(0);
								
								listener.getLogger().println("Commiting changes and pushing result of build number " + tag + " to master branch of " + remote.getName() + " repository");

								List<ObjectId> revs = git.revList("--max-count=1", "HEAD");
								
								BuildData buildData = build.getAction(BuildData.class);

								if (!revs.isEmpty() && !revs.get(0).equals(buildData.lastBuild.revision.getSha1())) {
									buildData.lastBuild.revision.setSha1(revs.get(0));
								}

								git.push(remote, "HEAD:master");
							}
	
							return true;
						}
					});
		} catch (Throwable e) {
			listener.error("Failed to push tags to origin repository: " + e.getMessage());
			build.setResult(Result.FAILURE);
			return false;
			
		}
		return canPerform;
	}

	public static final Descriptor<Publisher> DESCRIPTOR = new DescriptorImpl();

	public static class DescriptorImpl extends BuildStepDescriptor<Publisher> {

		public DescriptorImpl() {
			super(GitCommitPublisher.class);
		}

		public String getDisplayName() {
			return "Commit workspace and push merges back to origin";
		}

		public String getHelpFile() {
			return "/plugin/git/gitPublisher.html";
		}

		/**
		 * Performs on-the-fly validation on the file mask wildcard.
		 */
		public void doCheck(StaplerRequest req, StaplerResponse rsp)
				throws IOException, ServletException {
			new FormFieldValidator.WorkspaceFileMask(req, rsp).process();
		}

		public GitCommitPublisher newInstance(StaplerRequest req, JSONObject formData)
				throws FormException {
			return new GitCommitPublisher();
		}

		public boolean isApplicable(Class<? extends AbstractProject> jobType) {
			return true;
		}
	}

}
